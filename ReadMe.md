# Tervezői döntések dokumentációja a beadandó feladathoz
## Mezők modellezése
A kódot modulárisan építettem fel. Próbáltam betartani az objektum-orientált alapelveket. A mezők, amikre a karakter ráléphet osztályhierarchiába lettek szervezve.
Ennek az osztályhierarchiának a közös őse egy Field nevű absztrakt osztály. Ez előírja, hogy minden alosztály definiáljon egy Accept és egy Berak methódust.
Az Accept methódus adja meg, hogy milyen irányokból tudunk az adott mezőre lépni, a Berak methódus berakja az aktuális mezőt egy listába. Azért ezt a módszert választottam a listába való beszúráshoz, mert így nincs szükségünk típusellenőrzésre. Öröklés (inheritance) segítségével tudjuk kezelni, hogy bármely mező dinamikusan megvizsgálja önmagát és beleteszi a saját koordinátáit a listába. Újabb mezőtípusok felvétele nem okoz nehézséget, hiszen csak az adott leszármazott osztályban kell módosításokat elvégezni. A mezőkbe tudatosan nem vettem fel az adott mezők koordinátáit. Ennek az az oka, hogy könnyen lehessen a szoftvert bővíteni abba az irányba, hogy más pályatípusokat is tudjon támogatni. Pl.: ha nem egy grid-pályán, hanem egy gráf pályán mozogna a karakterünk, akkor nem kell az egyes mezőkbe változásokat implementálni.
## Térkép modellezése
A térkép logikájába került a pálya memória allokálása, a távolságok karbantartása és az egyes lépések validitásának ellenőrzése. A korábban említett koordináták logikája ebben az osztályban került implementálásra.
## BFS algoritmus
Az üzleti logika megvalósítása a szélességi bejárással történt. Ez a leghatékonyabb algoritmus nem súlyozott gráfokban legrövidebb utak megkeresésére. Komplexitása O(N+M), ahol N a csúcsok és M az élek száma. A távolságot tudatosan nem a BFS eljárásban állítottam be az egyes mezők számára, hanem a Terkep osztályban. Ennek az az oka, hogy az egyes mezőkhöz nem érdemes kívülről hozzáférnie egy külső methódusnak. Ez a Terkepnek a felelőssége.
### További javítási lehetőségek
- A hibajelzésen lehet javítani a Terkep::Leptet függvényben. Jelenleg -1-es számot használtam annak jelölésére, hogy érvénytelen/szabálytalan lépést próbál a karakterünk. Ehelyett optional<>-t kellene használni. Azért nem ezt használtam, mert valamiért C++14-ben nem fordult le a projekt CodeBlocks környezetben.
- A BFS-logikája kicsit kesze kusza a távolság beállításának lépésénél. Ez amiatt van, mert nem tudom felmérni, hogy milyen irányban fogjuk bővíteni a szoftvert. Jelen implementációban direkt elrejtésre került a BFS-algoritmustól a Terkep osztály belső reprezentációja. Ha olyan irányban bővülne a szoftver, amiben több algoritmust is kéne implementálni az adott pályára (pl.: mélységi keresés, összefüggő komponensek, Dijkstra-algoritmus (ha súlyozott lenne a pálya)), akkor érdemesebb lenne egy közös Algoritmus ősosztály, mely tartalmaz egy pálya példányt és így a pálya belső objektumaként tekinthető az algoritmusnak, ezért nyugodtan megvizsgálhatja annak a tartalmát a felelősségi körök megsértése nélkül.